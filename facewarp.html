<!DOCTYPE html>
<html>
  <head>
    <title>facewarp.js demo</title>
  </head>
  <body>
    <script src="lightgl.js"></script>
    <script type="x-shader/x-vertex" id="vs-coords">
varying vec2 coord;      
void main() {
  coord = gl_TexCoord.xy;
  //gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
  gl_Position = gl_Vertex;
}
    </script>
    <script type="x-shader/x-fragment" id="fs-warp">
uniform sampler2D storage;
uniform sampler2D texture;
varying vec2 coord;
void main() {
  vec4 raw = texture2D(storage, coord);
  vec2 texCoord = raw.st;
  gl_FragColor = texture2D(texture, texCoord);
}       
    </script>
    <script type="x-shader/x-fragment" id="fs-init">
varying vec2 coord;
void main() {
  gl_FragColor = vec4(coord.x, coord.y, 0, 0);  
}
    </script>
    <script type="x-shader/x-fragment" id="fs-update">
uniform sampler2D storage;
uniform vec2 dragPosition;
uniform vec2 delta;
varying vec2 coord;
void main() {
  // calculate how strongly this point is affected
  float dist = distance(coord, dragPosition);
  float d = 30.0 * dist;
  float effect = 0.0;
  if (d < 1.0) {
    // point selection function: 1 - 3d^2 + 2d^3
    effect = 1.0 - 3.0*d*d + 2.0*d*d*d;
  }

  // move the texture coordinates for this point accordingly
  vec4 cur = texture2D(storage, coord);
  gl_FragColor = vec4(cur.s + effect * delta.x, cur.t + effect * delta.y, 0, 0);  
}
    </script>

    <script>
// initialize WebGL
var gl = GL.create();

// create a plane mesh
// (there's only gl_Vertex buffer by default; `coords` adds gl_TexCoord)
var mesh = GL.Mesh.plane({coords: true, normals: true});

// initialize shaders from the <script> elements with supplied ids
var warpShader = new GL.Shader('vs-coords', 'fs-warp');
var storageInitShader = new GL.Shader('vs-coords', 'fs-init');
var storageUpdateShader = new GL.Shader('vs-coords', 'fs-update');

// load texture
var texture = new GL.Texture.fromURL("face.jpg");

// create storage (actually a texture) for texture coordinates
var storage = new GL.Texture(texture.width, texture.height);
//var storage = new GL.Texture(1024, 1024);

// face properties
var face = {
  width: function() { return gl.canvas.width },
  height: function() { return gl.canvas.height }
};

storage.drawTo(function() {
  storageInitShader.draw(mesh);
});

// dragging handler
gl.onmousemove = function(e) {
  if (e.dragging) {
    // TODO: do this with two textures, as rendering to the same texture
    // is undefined behaviour
    // update the storage
    storage.drawTo(function() {
      storage.bind(0);
      storageUpdateShader.uniforms({
        // dragging parameters
        dragPosition: [e.x / face.width(), 1.0 - e.y / face.height()],
        delta: [-e.deltaX / face.width(), e.deltaY / face.height()],
        storage: 0
      }).draw(mesh);
    });
  }
}

// drawing
gl.ondraw = function() {
  
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  gl.loadIdentity();
  //gl.translate(0, 0, -2.4);

  storage.bind(0);
  texture.bind(1);
  warpShader.uniforms({
    storage: 0,
    texture: 1
  }).draw(mesh);
}

// set canvas to be as high as the window, and use image aspect ratio for width
gl.canvas.height = window.innerHeight;
gl.canvas.width = texture.width / texture.height * gl.canvas.height;
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
// inject the canvas into DOM
document.body.appendChild(gl.canvas);

// start running the onupdate/ondraw loop
gl.animate();
    </script>
  </body>
</html>
